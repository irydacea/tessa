#!/usr/bin/env python3
'''
codename Tessa

Copyright (C) 2022 by Iris Morelle <iris@irydacea.me>
See COPYING for use and distribution terms.
'''

import argparse
import asyncio
import datetime
import logging
import sys
from typing import Any, List, Literal, Dict, Mapping, Sequence

import discord
from jsonc_parser.parser import JsoncParser
import jsonc_parser.errors

#from lib.diag import die
import lib.log as log


# Version number
TESSA_VERSION = '0.0.1'

# Configuration file path (override with -c/--config)
CONFIG_FILE_PATH = './tessa.jsonc'

# Maximum number of reactions allowed by Discord. Don't change this.
MAX_REACTIONS = 20


class TessaDiscordBot(discord.Client):
    class ConfigError(Exception):
        pass

    class ParameterError(Exception):
        pass

    def __init__(self, *args, **kwargs):
        '''
        Constructor.

        It sets the bot's intents and initial Discord status and activity.
        '''
        self._reactions = []
        self._banned_reactions = []
        self._guilds = {}

        intents = discord.Intents(guilds=True, guild_messages=True, guild_reactions=True)
        act = discord.Game(name='with your feelings')
        status = discord.Status.dnd

        super().__init__(*args, **kwargs, intents=intents, activity=act, status=status)

    async def on_connect(self):
        log.notice('Connected to Discord')

    async def on_ready(self):
        log.notice(f'Joined Discord as {self.user}')

    async def on_message(self, message):
        '''
        Handles posting of automatic reactions to new messages.
        '''
        if message.author == self.user:
            return
        if not self._is_auto_react_channel(message.guild, message.channel):
            return
        if not self._reactions:
            return

        log.debug(f'Guild {message.guild.id} channel {message.channel.id} message {message.id}')

        try:
            # Clear existing reactions in case the bot is running behind other
            # guild members' ability to react to messages
            await message.clear_reactions()
            # Discord wants us to add the reactions one by one sadly
            for reaction in self._reactions:
                new_reaction = discord.PartialEmoji.from_str(reaction)
                log.debug(f'Reaction: emote {new_reaction.name}:{new_reaction.id}' if ':' in reaction else f'Reaction: Unicode {reaction}')
                reaction_exec = asyncio.create_task(message.add_reaction(new_reaction))
                await reaction_exec
        except discord.NotFound as err:
            log.error(f'Invalid or missing reaction emoji: {err.text}')
        except discord.RateLimited as err:
            # This is global so may as well block the entire client on this
            log.error(f'Discord rate limit exceeded, waiting {err.retry_after}s')
            await asyncio.sleep(err.retry_after)
        except discord.HTTPException as err:
            log.error(f'Discord error adding reaction to message {message.id}: {err.status} {err.text}')

    async def on_reaction_add(self, reaction, user):
        '''
        Handles moderation of user reactions to messages.
        '''
        # NOTE: We use on_reaction_add here, not on_raw_reaction_add, so there's a risk
        #       that reactions on uncached messages will happen and we won't hear of them.
        #       For our use case this is a good enough compromise.
        if reaction.me:
            return
        message = reaction.message
        if not self._is_moderated_channel(message.guild, message.channel):
            return
        if not self._banned_reactions:
            return

        log.debug(f'Reaction {reaction!s} on guild {message.guild.id} channel {message.channel.id} message {message.id}')

        naughty = False
        emoji = str(reaction)
        if not emoji:
            log.notice('Reaction is an empty string, is discord okay?')
            return
        # Anything non-ASCII can't be a Discord implementation detail so it's
        # got to be an emoji right?
        if ord(emoji[0]) > 0x7F:
            # NOTE: We're really just trying to ignore emoji modifiers. This is
            # a very dirty hack but it should work for our use case.
            for char in emoji:
                if char in self._banned_reactions:
                    naughty = True
                    break
        # Otherwise compare the sequence wholesale
        elif emoji in self._banned_reactions:
            naughty = True

        if not naughty:
            return

        log.debug(f'Banned reaction {reaction!s} found on guild {message.guild.id} channel {message.channel.id} message {message.id}')
        # NOTE: we need to log the situation first, otherwise the list of users
        #       who reacted to the message is lost
        await self._do_modlog_reaction(message.guild, reaction)
        # TODO: REPEAT UNTIL THE REACTION IS FULLY GONE
        await message.clear_reaction(reaction)

    async def _do_modlog_reaction(self, guild, reaction):
        modlog_cid = self._modlog_channel_id(guild)
        if not modlog_cid:
            return
        # Odds are there's only gonna be one mention, but anyway
        reactor_mentions = ', '.join([user.mention async for user in reaction.users()])
        embed_body = (f'**Deleted bad reaction in {reaction.message.channel.mention!s} by {reactor_mentions!s}**\n'
                      f'{reaction!s} - [Jump to message]({reaction.message.jump_url!s})')
        log_embed = discord.Embed(
            colour=discord.Colour.fuchsia(),
            description=embed_body,
            timestamp=datetime.datetime.now())
        modlog_channel = await guild.fetch_channel(modlog_cid)
        await modlog_channel.send(embed=log_embed)

    def _modlog_channel_id(self, guild):
        if guild.id in self._guilds:
            return self._guilds[guild.id]['event_log']
        return 0

    def _channel_config(self, guild, channel):
        gid = guild.id
        chan = channel.id
        if gid in self._guilds and chan in self._guilds[gid]['channels']:
            return self._guilds[gid]['channels'][chan]
        else:
            return None

    def _is_auto_react_channel(self, guild, channel):
        '''
        Helper method to check if a guild+channel pair should have automatic reactions.
        '''
        channel_config = self._channel_config(guild, channel)
        return channel_config is not None and channel_config['auto_reactions']

    def _is_moderated_channel(self, guild, channel):
        '''
        Helper method to check if a guild+channel pair should have moderated reactions.
        '''
        channel_config = self._channel_config(guild, channel)
        return channel_config is not None and channel_config['moderate_reactions']

    def read_config(self, config):
        '''
        Processes the configuration JSON data.
        '''
        if 'guilds' in config:
            guilds = config['guilds']
            for guild_id_str, guild_cfg in guilds.items():
                guild_id = int(guild_id_str)
                if not guild_id: # Validation
                    raise TessaDiscordBot.ConfigError()
                if not guild_cfg.get('enabled', True):
                    log.debug(f'Skipping guild {guild_id} disabled by configuration')
                    continue
                self._guilds[guild_id] = {
                    'event_log': int(guild_cfg.get('event_log', 0)),
                    'channels':  {}
                }
                # Read channel configuration
                for key in guild_cfg.keys():
                    if not key.isdigit():
                        # Key isn't a channel id
                        continue
                    channel_cfg = guild_cfg[key]
                    channel_id = int(key)
                    if not channel_id: # Validation
                        raise TessaDiscordBot.ConfigError()
                    auto_reactions = bool(channel_cfg.get('auto_reactions', False))
                    moderate_reactions = bool(channel_cfg.get('moderate_reactions', False))
                    if not auto_reactions and not moderate_reactions:
                        log.debug(f'Skipping channel {channel_id} with no enabled actions')
                        continue
                    self._guilds[guild_id]['channels'][channel_id] = {
                        'auto_reactions':     auto_reactions,
                        'moderate_reactions': moderate_reactions,
                    }
                    log.info(f'Monitoring guild {guild_id} channel {channel_id} (auto reactions: {auto_reactions}, moderate reactions: {moderate_reactions}')
        else:
            log.warning('No guilds have been configured')
            return
        if 'reactions' in config:
            self.set_reactions(config['reactions'])
        else:
            log.warning('No reaction emojis have been configured')
        if 'banned_reactions' in config:
            self.set_banned_reactions(config['banned_reactions'])
        else:
            log.warning('No banned reaction emojis have been configured')

    def set_reactions(self, reactions: Sequence[str]):
        # These checks are really only here to catch configuration mistakes. If
        # Discord limits change we'll let the user off the hook otherwise.
        if len(reactions) > MAX_REACTIONS:
            log.warning(f'Excessive number of reaction emojis ({len(reactions)} > {MAX_REACTIONS})')
        elif not reactions:
            log.warning('No reaction emojis configured, kind of silly')
        self._reactions = reactions

    def set_banned_reactions(self, reactions: Sequence[str]):
        self._banned_reactions = reactions


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-d, --debug', action='store_true', dest='debug',
                        default=False,
                        help='prints extra debugging information')
    parser.add_argument('-v', '--verbose', action='store_true', dest='verbose',
                        default=False,
                        help='prints more information about actions')
    parser.add_argument('-c', '--config', action='store', type=str, dest='config',
                        default=CONFIG_FILE_PATH,
                        help='specifies the path to the Tessa configuration JSON file')
    args = parser.parse_args()

    print(f'''codename "Tessa" version {TESSA_VERSION}

    Config file path: {args.config}
''')

    logging.basicConfig(level=logging.WARNING)

    if args.verbose:
        log.set_log_level(log.LOG_LEVEL_INFO)
        logging.basicConfig(level=logging.INFO)
    if args.debug:
        log.set_log_level(log.LOG_LEVEL_DEBUG)
        logging.basicConfig(level=logging.DEBUG)

    config_fn = args.config
    config = None

    try:
        config = JsoncParser.parse_file(config_fn)
    except (jsonc_parser.errors.FileError, jsonc_parser.errors.ParserError) as err:
        log.error(f'Could not read configuration from {config_fn}: {err}')
        sys.exit(1)

    discord_token = config.get('token', None)
    if discord_token is None:
        log.error('No Discord bot token specified in the config file. Cannot continue.')
        sys.exit(1)

    client = TessaDiscordBot()
    client.read_config(config)
    client.run(discord_token)


if __name__ == '__main__':
    main()
